package Array;


import java.util.Arrays;

/**
 * 这题猛一看, 好像不简单
 *
 * 似乎要穷举出所有的分组可能, 然后找出最大的
 *
 * 我感觉显然不能这样做, 这样做这题不就太复杂了么?
 *
 * 那怎么办? 会不会一些特殊的分法就是解了? 既然穷举不了所有的分组, 不如试试几种特殊的分法看看情况.
 *
 * 比如对于
 * [6,2,6,5,1,2]
 *
 * 最容易想到的. 其实就是和随机一样.
 *
 * [(6,2), (6,5), (1,2)] , 然后就是2 + 5 + 2 = 9
 *
 * 这种随机的, 就不可能是最大的
 *
 * 还有没有其它的特殊分法? 现在是无序的, 所以前后两个其实就是代表了无序情况下的一般情况, 我们试试排个序
 *
 * [1, 2, 2, 5, 6, 6]
 *
 * 然后
 *
 * [(1, 2), (2, 5), (6, 6)] = 1 + 2 + 6 = 9
 *
 * 这种是不是最大的呢? 可能是, 因为这种分法对于一个数组来说, 只有一种可能. 我们不妨再试试其它例子.
 *
 * [1,4,3,2] = [1, 2, 3, 4] = [(1, 2), (3, 4)] = 1 + 3 = 4
 *
 * 现在这种分法对于两个case正好是最佳分法? 难道是巧合? 会不会这种就是最优的?
 *
 * 能不能证明? 如果能证明那么就不需要穷举了. 要想证明的话? 我们可以假设一下, 如有另一种分法可以得到更大的值.
 *
 * 如
 * [1, 4, 3, 2] = [(a1, a2), (b1, b2)] = n1 + n2 > 1 + 3
 * 假设 n1 < n2
 * 那么, 肯定存在, n1 > 1 或者 n2 > 3 (因为如果 n1 <= 1 && n2 <= 3, 那么 n1 + n2 <= 1 + 3)
 *
 * 好, 现在两种情况, 比如说n1 > 1, 说明 a1, a2 > 1, 那么1肯定被分到其它的组, 而如果分到另一组的话,
 * 比如分到第二组 (1, b2), 那么, 这一组的最小值要么是1, 要么 < 1.
 *
 * 靠, 反正法到这里好麻烦, 试试换一个思路, 比如不用反证法, 是不是能直观的看出这种划分就是最优解.
 *
 * 比如说, 我们想让最后结果最大, 那么, 怎么才能最大呢? 朴素的想法, 是不是相加的数越大越好.
 *
 * 如果说4这个数, 它和谁分一组呢? 1, 2, 3? 应该和3,
 *
 * 那么还剩1, 2, 同理, 都是最大和次大的分一组. 这样, 可以使得两者较小的尽量大.
 *
 * 而我直观上的感觉好像就是这么一回事, 比如4,2, 那么, 3就是最大, 它不可能在最后相加的数之中.
 *
 * 由这种朴素的想法, 所以可以得出结论.
 *
 *
 * 启示:
 *
 * 这题猛一看要穷举所有情况, 但显然是复杂了, 超过大脑的容量了.
 * 于是想到, 能不能列举几个特殊的情况来看看, 特殊情况大脑还是能想到了.
 *
 * 于是想出先排个序, 再分组.
 * 而且又是多么希望这种分组就是最优解啊? (因为这样就不用穷举了)
 *
 * 所以下一步就是看看能不能证明一下, 如果能证明就太好了.
 *
 * 但是在证明过程中, 如果太数学了, 自己数学也不太好, 感觉越证越复杂.
 * 于是想直观的感受一下是不是这种情况是最优的.
 * 感受之后, 感觉它确实是最优的.
 *
 * 于是, 真的就是最优的.
 *
 */
public class Array_Partition {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);

        int result = 0;
        for (int i = 0; i < nums.length; i += 2) {
            result += nums[i];
        }

        return result;
    }
}
