package Array;

/**
 * 方法一:
 * 直观的做法就是找到arr中的所有奇数子数组, 然后加进来
 *
 * 方法二:
 * 要求一个O(n), 方法一不是O(n)的. O(n)启示我们最后的结果其实可以看成某种每个元素的和.
 *
 * 因为最后的和看起来是奇数子数组相加, 但其实是每个元素相加, 只是每个元素出现的次数不同.
 *
 * 这启示我们确定一个每个元素出现的次数有什么规律.
 *
 * 以 arr = [1,4,2,5,3]为例子, 所有奇数子数组为
 *
 * [1] = 1
 * [4] = 4
 * [2] = 2
 * [5] = 5
 * [3] = 3
 * [1,4,2] = 7
 * [4,2,5] = 11
 * [2,5,3] = 10
 * [1,4,2,5,3] = 15
 *
 * 这个数组长为5, 奇数子数组的长为 1, 3, 5
 *
 * 1 = 3
 * 4 = 4
 * 2 = 5
 * 5 = 4
 * 3 = 3
 *
 * 看这数, 似乎是有某种规律的.
 *
 * 再举一个偶数个元素的例子
 *
 * [1, 4, 2, 5]
 *
 * [1]
 * [4]
 * [2]
 * [5]
 * [1, 4, 2]
 * [4, 2, 5]
 *
 * 1 = 2
 * 4 = 3
 * 2 = 3
 * 5 = 2
 *
 * 发现出现次数是对称的, 这是巧合么? 其实不是, 比如1和5, 一个是第一位, 一个是最后一位, 但其实数子数组元素个数时, 并不在乎顺序
 * 所以肯定是对称的.
 *
 * 那么, 找到出现次数的第一个规律
 *
 * 1. 一定是对称的.
 *
 * 那么, 这个出现次数开头是多少呢?
 *
 * 这个不难, 其实就是和数组元素的个数有关, 有几种长度的奇数子数组, 就是几
 *
 * 现在解决了第二个问题
 *
 * 2. 出现的开头次数就是看和几种长度的子数组.
 *
 * 那么还有最后一个问题我们就知道所有元素的次数了.
 * 后一位的出现次数是多少呢?
 *
 * 看目前的例子是比前一个多一. 这是巧合吗?
 *
 * 这个不好证明, todo
 *
 * [10, 11, 12]
 *
 * [10]
 * [11]
 * [12]
 * [10, 11, 12]
 *
 * 10 = 2
 * 11 = 2
 * 12 = 2;
 */
public class Sum_of_All_Odd_Length_Subarrays {
    public int sumOddLengthSubarrays(int[] arr) {

        int sum = 0;
        int i = 0, j = arr.length - 1;

        // 计算有多少种长度子数组
        // begin也是i所指向的数字出现的次数
        int begin = (int) Math.ceil(arr.length / 2.0);

        while (i < j) {
            sum += arr[i] * begin + arr[j] * begin;
            begin++;
            i++;
            j--;
        }

        if (i == j) {
            sum += arr[i] * begin;
        }

        return sum;
    }
}
